////////////////////////////////////////////////////////////////////////////////
Функция ПолучитьСоединение(СтрокаСоединения="",СтрокаОшибок="", ОткрыватьТранзакцию = Ложь) Экспорт
	Попытка
		Соединение = NSI_РаботаСАДОПовторногоИспользования.ПолучитьСоединение(СтрокаСоединения, СтрокаОшибок, ОткрыватьТранзакцию);
		Текст = Соединение.CommandText;
	Исключение
		ОбновитьПовторноИспользуемыеЗначения();
		Соединение = NSI_РаботаСАДОПовторногоИспользования.ПолучитьСоединение(СтрокаСоединения, СтрокаОшибок, ОткрыватьТранзакцию);
		Если Соединение = Неопределено Тогда
			ВызватьИсключение("Не удалось установить соединение с базой. Строка подключения "+СтрокаСоединения+". Описание ошибки = "+СтрокаОшибок);
		КонецЕсли;
	КонецПопытки;
	Возврат Соединение;
КонецФункции
////////////////////////////////////////////////////////////////////////////////
Функция ВыполнитьЗапрос(СтрокаСоединения = "Provider=OraOLEDB.Oracle;Password=view;User ID=taxi_view;Data Source=OsksProd.world;Persist Security Info=False;",ТекстЗапроса,ТекстКоманды="",СтрокаОшибок="",ВозвращатьПустуюТЗ = Ложь) Экспорт
	OraDatabase=ПолучитьСоединение(СтрокаСоединения,СтрокаОшибок);
	OraDatabase.commandType = 8;
	Если ТекстКоманды<>"" Тогда
		Попытка
			OraDatabase.CommandText=ТекстКоманды;
			Выборка=OraDatabase.Execute();
		Исключение	
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, НСтр("ru = 'Ошибка выполнения команды:'; en = 'Сommand execution failed:'")+ОписаниеОшибки());
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ТекстЗапроса:" + Символы.ПС + ТекстКоманды);
			//Если Константы._СообщатьОбОшибках.Получить() Тогда
				//СообщениеОбОшибке = Новый СообщениеПользователю;
				//СообщениеОбОшибке.Текст = СтрокаОшибок;
				//СообщениеОбОшибке.Сообщить();
			//КонецЕсли;
			Возврат Ложь;
		КонецПопытки;	
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(ТекстЗапроса) Тогда//Если нужно выполнить только команду то проверим, не возвращает ли команда набор записей
		Попытка//Если результатом выполнения не является набор записей, то свойство EOF у выборки недоступно...
			ЗапросПустой = Выборка.EOF;
		Исключение//значит команда не вернула набор записей - возвратим Истина т.к. команда выполнене, а запрос выполнять не надо...
			Возврат Истина;
		КонецПопытки;
	КонецЕсли;
	Если СокрЛП(ТекстЗапроса)<>"" Тогда
		Попытка
			OraDatabase.CommandText=ТекстЗапроса;
			Выборка=OraDatabase.Execute();
		исключение	
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, НСтр("ru = 'Ошибка выполнения запроса:'; en = 'Query execution failed:'")+ОписаниеОшибки());
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ТекстЗапроса:" + Символы.ПС + ТекстЗапроса);
			//Если Константы._СообщатьОбОшибках.Получить() Тогда
			//	СообщениеОбОшибке = Новый СообщениеПользователю;
			//	СообщениеОбОшибке.Текст = СтрокаОшибок;
			//	СообщениеОбОшибке.Сообщить();
			//КонецЕсли;
			Возврат Ложь;
		конецпопытки;
	КонецЕсли;
	Если Выборка.EOF Тогда//Запрос пустой!
		Если ВозвращатьПустуюТЗ Тогда
			Поля=Выборка.Fields;
			КолКолонок=Поля.Count;
			пТЗ=Новый ТаблицаЗначений();
			Для ш=0 по КолКолонок-1 цикл
				Поле=Поля.Item(ш);
				Если Поле.Type=131 тогда//число
					пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(Поле.DefinedSize,Поле.NumericScale)));
				ИначеЕсли Поле.Type=5 тогда//Число для Xls
					пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(20,2)));
				ИначеЕсли Поле.Type=7 тогда//Дата для Xls
					пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Дата",,,Новый КвалификаторыДаты()));
				ИначеЕсли Поле.Type=135 тогда//дата
					пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Дата",,,Новый КвалификаторыДаты()));
				ИначеЕсли Поле.Type=139 тогда//число
					пТочность=Поле.NumericScale;
					пТочность=?(пТочность=255,8,пТочность);
					пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(Поле.DefinedSize,пТочность)));	
				Иначе//Видимо это строка
					Длина = 255;
					Попытка
						Если ЗначениеЗаполнено(Поле.DefinedSize) и Поле.DefinedSize<255 Тогда
							Длина = Поле.DefinedSize
						КонецЕсли;
					Исключение
					КонецПопытки;
					пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(Длина)));
				КонецЕсли;	
			КонецЦикла;
			Возврат пТЗ;
		Иначе
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, НСтр("ru = 'Результат пустой!'; en = 'The result is empty!'"));
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ТекстЗапроса:" + Символы.ПС + ТекстЗапроса);
			//Если Константы._СообщатьОбОшибках.Получить() Тогда
			//	СообщениеОбОшибке = Новый СообщениеПользователю;
			//	СообщениеОбОшибке.Текст = СтрокаОшибок;
			//	СообщениеОбОшибке.Сообщить();
			//КонецЕсли;
			Возврат Неопределено;//Если результат пустой - вернем "Неопределено"
		КонецЕсли;

	КонецЕсли;
	попытка
		Поля=Выборка.Fields;
		КолКолонок=Поля.Count;
		пТЗ=Новый ТаблицаЗначений();
		Для ш=0 по КолКолонок-1 цикл
			Поле=Поля.Item(ш);
			Если Поле.Type=131 тогда//число
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(Поле.DefinedSize,Поле.NumericScale)));
			ИначеЕсли Поле.Type=5 тогда//Число для Xls
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(20,2)));
			ИначеЕсли Поле.Type=7 тогда//Дата для Xls
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Дата",,,Новый КвалификаторыДаты()));
			ИначеЕсли Поле.Type=135 тогда//дата
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Дата",,,Новый КвалификаторыДаты()));
			ИначеЕсли Поле.Type=139 тогда//число
				пТочность=Поле.NumericScale;
				пТочность=?(пТочность=255,8,пТочность);
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(Поле.DefinedSize,пТочность)));	
			Иначе//Видимо это строка
				Длина = 255;
				Попытка
					Если ЗначениеЗаполнено(Поле.DefinedSize) и Поле.DefinedSize<255 Тогда
						Длина = Поле.DefinedSize
					КонецЕсли;
				Исключение
				КонецПопытки;
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(Длина)));
			КонецЕсли;	
		КонецЦикла;	
		МассДанныхКом=Новый COMSafeArray(Выборка.GetRows());
		Выборка.Close();
		МассДанных=МассДанныхКом.Выгрузить();
		Для каждого СтрМасс из МассДанных цикл
			СтрТЗ=пТЗ.Добавить();
			Для ш=0 по пТЗ.Колонки.Количество()-1 цикл
				СтрТЗ[ш]=СтрМасс[ш];
			КонецЦикла;	
		КонецЦикла;	
	исключение
		NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, НСтр("ru = 'Ошибка получения набора полей:'; en = 'Failure to get a set of fields:'") + ОписаниеОшибки());
		NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ТекстЗапроса:" + Символы.ПС + ТекстЗапроса);
		//Если Константы._СообщатьОбОшибках.Получить() Тогда
		//	СообщениеОбОшибке = Новый СообщениеПользователю;
		//	СообщениеОбОшибке.Текст = СтрокаОшибок;
		//	СообщениеОбОшибке.Сообщить();
		//КонецЕсли;
		возврат Ложь;
	конецпопытки;	
	возврат пТЗ;
КонецФункции

Функция IM_ЗаписатьТЗВТаблицуВСоединении(OraDatabase,ТЗ,ИмяТаблицы,ТипыДанных,СтрокаОшибок) Экспорт
	OraDatabase.CommandText="";
	пПоляВставки="";
	пПараметрыВставки="";
	КолПараметров=OraDatabase.Parameters.Count-1;
	Для ш=0 по КолПараметров цикл
		OraDatabase.Parameters.Delete(0);
	КонецЦикла;	
	Для Каждого пКолонка из ТЗ.Колонки цикл
		пПоляВставки=пПоляВставки+","+пКолонка.Имя;
		пПараметрыВставки=пПараметрыВставки+",?";
		пТипПараметра=неопределено;
		Если не ТипыДанных.Свойство(пКолонка.Имя,пТипПараметра) тогда
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, НСтр("ru = 'Ошибка выполнения записи в таблицу ('; en = 'Failed to write to the table ('")+ИмяТаблицы+НСтр("ru = '): Тип колонки '''; en = '): Column type '''")+пКолонка.Имя+"ru = ''' не описан в структуре типов.'; en = ''' Is not described in the structure types.'");
			Если Константы._СообщатьОбОшибках.Получить() Тогда
				СообщениеОбОшибке = Новый СообщениеПользователю;
				СообщениеОбОшибке.Текст = СтрокаОшибок;
				СообщениеОбОшибке.Сообщить();
			КонецЕсли;
			возврат Ложь;
		КонецЕсли;	
		пПарам=OraDatabase.CreateParameter("@"+пКолонка.Имя,пТипПараметра.Тип);
		пПарам.Size=пТипПараметра.Размер;
		OraDatabase.Parameters.Append(пПарам);
//		OraDatabase.Parameters.Append(OraDatabase.CreateParameter("@"+пКолонка.Имя,пТипПараметра.Тип,,пТипПараметра.Размер));
	КонецЦикла;	
	пПоляВставки=Сред(пПоляВставки,2);
	пПараметрыВставки=Сред(пПараметрыВставки,2);
	ТекстЗапроса="insert into "+ИмяТаблицы+"("+пПоляВставки+") values ("+пПараметрыВставки+")";
	OraDatabase.CommandText=ТекстЗапроса;
	Для Каждого пСтрокаТЗ из ТЗ цикл
		Попытка
			Для Каждого пКолонка из ТЗ.Колонки цикл
				OraDatabase.Parameters.Item("@"+пКолонка.Имя).Value=?(OraDatabase.Parameters.Item("@"+пКолонка.Имя).Type=202, Формат(пСтрокаТЗ[пКолонка.Имя],"ЧГ="), пСтрокаТЗ[пКолонка.Имя]);
			КонецЦикла;	
			Выборка=OraDatabase.Execute();
		исключение	
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, НСтр("ru = 'Ошибка выполнения записи в таблицу ('; en = 'Failed to write to the table ('")+ИмяТаблицы+")"+ОписаниеОшибки()+"("+пКолонка.Имя+"="+пСтрокаТЗ[пКолонка.Имя]+")");
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ТекстЗапроса:" + Символы.ПС + ТекстЗапроса);
			//Если Константы._СообщатьОбОшибках.Получить() Тогда
			//	СообщениеОбОшибке = Новый СообщениеПользователю;
			//	СообщениеОбОшибке.Текст = СтрокаОшибок;
			//	СообщениеОбОшибке.Сообщить();
			//КонецЕсли;
			возврат Ложь;
		конецпопытки;	
	КонецЦикла;	
	возврат Истина;
КонецФункции

Процедура УстановитьОсновнойОтбор(аЭлемент,аПоле,аЗначение,аОператор=Неопределено,аСкрывать=Истина) Экспорт
	пПолеОтбора=Новый ПолеКомпоновкиДанных(аПоле);
	пЭлементыОтбора=аЭлемент.Отбор.Элементы;
	Для Каждого пЭлементОтбора Из пЭлементыОтбора Цикл
		Если ТипЗнч(пЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			Продолжить;
		КонецЕсли;
		Если пЭлементОтбора.ЛевоеЗначение=пПолеОтбора Тогда
			пЭлементыОтбора.Удалить(пЭлементОтбора);
			Прервать;
		КонецЕсли;
	КонецЦикла;	
	ЭлементОтбора=пЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбора.ЛевоеЗначение=пПолеОтбора;
	ЭлементОтбора.ВидСравнения=?(аОператор=Неопределено,ВидСравненияКомпоновкиДанных.Равно,аОператор);
	ЭлементОтбора.Использование=Истина;
	ЭлементОтбора.РежимОтображения=?(аСкрывать,РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный,РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ);
	ЭлементОтбора.ПравоеЗначение=аЗначение;
КонецПроцедуры

Функция ВыполнитьЗапросИзСуществующегоПодключения(OraDatabase,ТекстЗапроса,ТекстКоманды="",СтрокаОшибок="") Экспорт
	Если ТекстКоманды<>"" Тогда
		Попытка
			OraDatabase.CommandText=ТекстКоманды;
			Выборка=OraDatabase.Execute();
		исключение	
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ВыполнитьКоманду.Ошибка выполнения:"+ОписаниеОшибки());
			NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ТекстЗапроса:" + Символы.ПС + ТекстКоманды);
			//Если Константы._СообщатьОбОшибках.Получить() Тогда
			//	СообщениеОбОшибке = Новый СообщениеПользователю;
			//	СообщениеОбОшибке.Текст = СтрокаОшибок;
			//	СообщениеОбОшибке.Сообщить();
			//КонецЕсли;
			возврат Ложь;
		конецпопытки;	
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(ТекстЗапроса) Тогда
		Возврат Истина;
	КонецЕсли;
	Попытка
		OraDatabase.CommandText=ТекстЗапроса;
		Выборка=OraDatabase.Execute();
	исключение	
		NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ВыполнитьЗапрос.Ошибка выполнения:"+ОписаниеОшибки());
		NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ТекстЗапроса:" + Символы.ПС + ТекстЗапроса);
		//Если Константы._СообщатьОбОшибках.Получить() Тогда
		//	СообщениеОбОшибке = Новый СообщениеПользователю;
		//	СообщениеОбОшибке.Текст = СтрокаОшибок;
		//	СообщениеОбОшибке.Сообщить();
		//КонецЕсли;
		возврат Ложь;
	конецпопытки;
	Если Выборка.EOF Тогда//Запрос пустой!
		NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, НСтр("ru = 'Результат пустой!'; en = 'The result is empty!'"));
		//Если Константы._СообщатьОбОшибках.Получить() Тогда
		//	СообщениеОбОшибке = Новый СообщениеПользователю;
		//	СообщениеОбОшибке.Текст = СтрокаОшибок;
		//	СообщениеОбОшибке.Сообщить();
		//КонецЕсли;
		Возврат Неопределено;//Если результат пустой - вернем "Неопределено"
	КонецЕсли;
	попытка
		Поля=Выборка.Fields;
		КолКолонок=Поля.Count;
		пТЗ=Новый ТаблицаЗначений();
		Для ш=0 по КолКолонок-1 цикл
			Поле=Поля.Item(ш);
			Если Поле.Type=131 тогда//число
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(Поле.DefinedSize,Поле.NumericScale)));
			ИначеЕсли Поле.Type=135 тогда//дата
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Дата",,,Новый КвалификаторыДаты()));
			ИначеЕсли Поле.Type=139 тогда//число
				пТочность=Поле.NumericScale;
				пТочность=?(пТочность=255,8,пТочность);
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(Поле.DefinedSize,пТочность)));	
			Иначе	
				пТЗ.Колонки.Добавить(Поле.Name,Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(250)));
			КонецЕсли;	
		КонецЦикла;	
		МассДанныхКом=Новый COMSafeArray(Выборка.GetRows());
		Выборка.Close();
		МассДанных=МассДанныхКом.Выгрузить();
		Для каждого СтрМасс из МассДанных цикл
			СтрТЗ=пТЗ.Добавить();
			Для ш=0 по пТЗ.Колонки.Количество()-1 цикл
				СтрТЗ[ш]=СтрМасс[ш];
			КонецЦикла;	
		КонецЦикла;	
	исключение
		NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "IM_RecordSet2ТЗ.Ошибка выполнения:"+ОписаниеОшибки());
		NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ТекстЗапроса:" + Символы.ПС + ТекстЗапроса);
		//Если Константы._СообщатьОбОшибках.Получить() Тогда
		//	СообщениеОбОшибке = Новый СообщениеПользователю;
		//	СообщениеОбОшибке.Текст = СтрокаОшибок;
		//	СообщениеОбОшибке.Сообщить();
		//КонецЕсли;
		возврат Ложь;
	конецпопытки;	
	возврат пТЗ;
КонецФункции

//Проверяет отсутствие ссылок на указанную таблицу "ИмяТаблицы" в связанных данных
//"Ключ" - это ключевое поле проверяемой таблицы
&НаСервере
Функция ПроверитьВозможностьУдаления(СтрокаПодключения,ИмяТаблицы,Ключ,СтрокаОшибок = "") Экспорт
	СтрокаОшибок = "";
	ТекстЗапроса = "select * from table(smload_pk_at_interface.fn_check_delete('" + ИмяТаблицы + "'," + Формат(Ключ,"ЧГ=") + "))";
	ТЗ = NSI_РаботаСАДО.ВыполнитьЗапрос(СтрокаПодключения,ТекстЗапроса,,СтрокаОшибок);
	Если ТЗ = ЛОЖЬ Тогда
		Возврат ЛОЖЬ;
	КонецЕсли;
	Если ТЗ = Неопределено Тогда//Пустой результат - значит такого источника еще нет в таблицах - Можно удалять!
		Возврат ИСТИНА;
	КонецЕсли;
	Если ТЗ[0].IS_REF_ROW=0 Тогда//На удаляемый элемент нет ссылок в данных - можно удалять
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

//Проверяет наличие таблицы/вьюхи в указанной схеме и БД
&НаСервере
Функция ИсточникСуществует(СтрокаПодключения,ИмяТаблицы="",ИмяСхемы="",ИмяБД="") Экспорт
	ТекстЗапроса = "select smload_pk_at_interface.fn_check_source('" + ИмяТаблицы + "','" + ИмяСхемы + "','" + ИмяБД + "') a from dual";
	СтрокаОшибок = "";
	ТЗ = NSI_РаботаСАДО.ВыполнитьЗапрос(СтрокаПодключения,ТекстЗапроса,,СтрокаОшибок);
	Если ТЗ = Ложь или ТЗ[0].a=0 Тогда
		Возврат Ложь
	КонецЕсли;
	Возврат Истина;
КонецФункции

Функция ЗакрытьЛинкиСуществующегоПодключения(OraDatabase, СтрокаОшибок = "") Экспорт
	ТекстКоманды = "BEGIN
	|COMMIT;
	|FOR cur_link IN (SELECT DB_Link FROM user_db_links) LOOP
	|   BEGIN
	|        dbms_session.close_database_link(cur_link.DB_Link);
	|    EXCEPTION
	|        WHEN OTHERS THEN NULL;
	|    END;
	|END LOOP;
	|END;"; 
	
	Попытка
		OraDatabase.CommandText = ТекстКоманды;
		Выборка=OraDatabase.Execute();
	исключение	
		NSI_ОбщиеПроцедурыКлиентСервер.ДобавитьСообщениеВСтрокуОшибок(СтрокаОшибок, "ВыполнитьКоманду. Ошибка выполнения:"+ОписаниеОшибки());
		возврат Неопределено;
	конецпопытки;	
	
	Возврат Истина;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ДЕРЕВОМ ЗНАЧЕНИЙ

// Функция формирует значение нового ключа строки табличной части.
//
// Параметры:
// Дерево - дерево значений
//
Функция ПолучитьНовыйКлючСтрокиДерева(Дерево, СписокКлючей = Неопределено) Экспорт

    Если СписокКлючей = Неопределено Тогда
        СписокКлючей = Новый СписокЗначений;
        СписокКлючей.Добавить(0);
    КонецЕсли;
    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        СписокКлючей.Добавить(СтрокаДерева.КлючСтроки);
        ПолучитьНовыйКлючСтрокиДерева(СтрокаДерева, СписокКлючей);
        СписокКлючей.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
        МаксКлюч = СписокКлючей[0].Значение + 1;
    КонецЦикла;
    Возврат МаксКлюч;

КонецФункции // ПолучитьНовыйКлючСтрокиДерева()

// Процедура обновляет ключи связи в дереве значений
//
Процедура ОбновитьКлючиСвязиВДеревеЗначений(Дерево) Экспорт

    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        Попытка
            СтрокаДерева.КлючСвязи = СтрокаДерева.Родитель.КлючСтроки;
        Исключение
            СтрокаДерева.КлючСвязи = 0;
        КонецПопытки;
        ОбновитьКлючиСвязиВДеревеЗначений(СтрокаДерева);
    КонецЦикла;

КонецПроцедуры // ОбновитьКлючиСвязиВДеревеЗначений()

// Процедура обновляет ключи связи в дереве значений
//
Процедура ОбновитьКлючиСтрокВДеревеЗначений(Дерево, КлючСтроки = 1) Экспорт

    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        СтрокаДерева.КлючСтроки = КлючСтроки;
        КлючСтроки = КлючСтроки + 1;
        ОбновитьКлючиСтрокВДеревеЗначений(СтрокаДерева, КлючСтроки);
    КонецЦикла;

КонецПроцедуры // ОбновитьКлючиСвязиВДеревеЗначений()

// Процедура выгружает данные из дерева значений в таблицу значений
// данные выгружаются только в таблицу со сходным набором реквизитов
//
Функция ВыгрузитьДеревоЗначенийВТаблицуЗначений(Дерево, Таблица = Неопределено) Экспорт

    Если Таблица = Неопределено Тогда
        Таблица = Новый ТаблицаЗначений;
        Для Каждого Колонка Из Дерево.Колонки Цикл
            Таблица.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
        КонецЦикла;
    КонецЕсли;
    Для Каждого СтрокаДерева Из Дерево.Строки Цикл
        ЗаполнитьЗначенияСвойств(Таблица.Добавить(), СтрокаДерева);
        ВыгрузитьДеревоЗначенийВТаблицуЗначений(СтрокаДерева, Таблица);
    КонецЦикла;
    Возврат Таблица;

КонецФункции //ВыгрузитьДеревоЗначенийВТаблицуЗначений()

// Процедура выгружает данные из таблицы значений в дерево значений
// данные выгружаются только в таблицу со сходным набором реквизитов
//
// Параметры:
//
// КлючСтроки - имя колонки ТаблицыЗначений - уникальный идентификатор
// КлючСвязи - имя колонки ТаблицыЗначений - указатель привязки к строке Дерева,
// своего рода указатель на "Родителя"
//
Функция ВыгрузитьТаблицуЗначенийВДеревоЗначений(Таблица, КлючСтроки = "КлючСтроки", КлючСвязи = "КлючСвязи") Экспорт

    Дерево = Новый ДеревоЗначений;
    Для Каждого Колонка Из Таблица.Колонки Цикл
        Дерево.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
    КонецЦикла;
    Для Каждого СтрокаТаблицы Из Таблица Цикл
        СтрокаГруппировки = Дерево.Строки.Найти(СтрокаТаблицы[КлючСвязи], КлючСтроки,Истина);
        Если СтрокаГруппировки = Неопределено Тогда
            ЗаполнитьЗначенияСвойств(Дерево.Строки.Добавить(), СтрокаТаблицы);
        Иначе
            ЗаполнитьЗначенияСвойств(СтрокаГруппировки.Строки.Добавить(), СтрокаТаблицы);
        КонецЕсли;
    КонецЦикла;
    Возврат Дерево;

КонецФункции //ВыгрузитьТаблицуЗначенийВДеревоЗначений()

// Процедура устанавливает значение во всем дереве значений
//
Процедура УстановитьЗначениеКолонкиДерева(Дерево, Колонка, Значение) Экспорт

    Для каждого СтрокаДерева Из Дерево.Строки Цикл
        СтрокаДерева[Колонка] = Значение;
        УстановитьЗначениеКолонкиДерева(СтрокаДерева, Колонка, Значение);
    КонецЦикла;

КонецПроцедуры //УстановитьЗначениеКолонкиДерева()

// Процедура копирует подчиненные строки дерева значений
//
Процедура СкопироватьПодчиненныеСтроки(СтрокаПриемник, СтрокаИсточник)

    Для каждого Строка Из СтрокаИсточник.Строки Цикл
        НоваяСтрока = СтрокаПриемник.Строки.Добавить();
        НоваяСтрока.КлючСвязи = СтрокаПриемник.КлючСтроки;
        ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
        СкопироватьПодчиненныеСтроки(НоваяСтрока, Строка);
    КонецЦикла;

КонецПроцедуры // СкопироватьПодчиненныеСтроки()

// Процедура переносит выделенные строки дерева значений в указанную ветку
//
Процедура ПеренестиСтрокиДереваЗначений(СтрокаПриемник, ВыделенныеСтроки) Экспорт

    Если НЕ СтрокаПриемник = Неопределено Тогда
        МассивСтрок = Новый Массив;
        Для Каждого СтрокаПереноса Из ВыделенныеСтроки Цикл
            МассивСтрок.Добавить(СтрокаПереноса);
            НоваяСтрока = СтрокаПриемник.Строки.Добавить();
            СкопироватьПодчиненныеСтроки(НоваяСтрока, СтрокаПереноса);
            ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаПереноса);
            НоваяСтрока.КлючСвязи = СтрокаПриемник.КлючСтроки;
        КонецЦикла;
        Для Каждого СтрокаДерева Из МассивСтрок Цикл
            Если СтрокаДерева.Родитель = Неопределено Тогда
                СтрокаДерева.Строки.Удалить(СтрокаДерева);
            Иначе
                СтрокаДерева.Родитель.Строки.Удалить(СтрокаДерева);
            КонецЕсли;
        КонецЦикла;
    КонецЕсли;

КонецПроцедуры //ПеренестиСтрокиДереваЗначений()   

Функция ВыполнитьНаСервере(ВернутьРезультат, Команда, Параметр1 = Неопределено, Параметр2 = Неопределено, Параметр3 = Неопределено, Параметр4 = Неопределено) Экспорт  
	Если ВернутьРезультат Тогда 
		Возврат Вычислить(Команда);
	Иначе 
		Выполнить(Команда); 
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

Функция ВыполнитьПредопределеннуюФункциюOracle(База, ПредопреденнаяФункция, СписокПараметров=Неопределено) Экспорт
	Если СписокПараметров = Неопределено Тогда
		СписокПараметров = Новый Массив;
	КонецЕсли;
	Если ТипЗнч(База) = Тип("Строка") Тогда
		БазаСсылка = NSI_МодульПовторногоИспользования.ПолучитьСсылкуИБПоИмениБазы(База);
	ИначеЕсли ТипЗнч(База)=Тип("СправочникСсылка.NSI_СписокВИБ") Тогда
		БазаСсылка = База;
	КонецЕсли;
	Если Не БазаСсылка.ВидБД = Перечисления.NSI_ВидыБД.Oracle Тогда
		ВызватьИсключение "База "+БазаСсылка+" не является базой Oracle";
	КонецЕсли;		
	СтрокаСоединения = "Provider=OraOLEDB.Oracle;Password="+БазаСсылка.Oracle_password+";User ID="+БазаСсылка.Oracle_user+";Data Source="+БазаСсылка.Oracle_schema+";Persist Security Info=False;";
	Если ПредопреденнаяФункция = Перечисления.NSI_ПредопределенныеФункцииOracle.ПолучитьСписокОбъектов Тогда
		ТаблицаРезультата = NSI_РаботаСАДО.ВыполнитьЗапрос(СтрокаСоединения, "select OBJECT_NAME, OBJECT_TYPE, TEMPORARY from user_objects where object_type in ('VIEW', 'TABLE', 'PACKAGE') and TEMPORARY='N'",,,Истина);
	ИначеЕсли ПредопреденнаяФункция = Перечисления.NSI_ПредопределенныеФункцииOracle.ПолучитьСписокПолейТаблицы Тогда
		Если СписокПараметров.Количество()<1 Тогда
			ВызватьИсключение "В списке параметров необходимо передать массив [Table_name]";
		КонецЕсли;
		ТаблицаРезультата = NSI_РаботаСАДО.ВыполнитьЗапрос(СтрокаСоединения, "select COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, COLUMN_ID from user_tab_columns where table_name = '"+СписокПараметров[0]+"'",,,Истина);
	ИначеЕсли ПредопреденнаяФункция = Перечисления.NSI_ПредопределенныеФункцииOracle.ПолучитьСписокПроцедур Тогда
		Если СписокПараметров.Количество()<1 Тогда
			ВызватьИсключение "В списке параметров необходимо передать массив [Package_name]";
		КонецЕсли;
		ТаблицаРезультата = NSI_РаботаСАДО.ВыполнитьЗапрос(СтрокаСоединения, "select procedure_name, object_name from all_procedures where object_name = '"+СписокПараметров[0]+"'",,,Истина);
	ИначеЕсли ПредопреденнаяФункция = Перечисления.NSI_ПредопределенныеФункцииOracle.ПолучитьСписокПараметровПроцедуры Тогда
		Если СписокПараметров.Количество()<1 Тогда
			ВызватьИсключение "В списке параметров необходимо передать массив [Package_name, Procedure_name]";
		КонецЕсли;
		ТаблицаРезультата = NSI_РаботаСАДО.ВыполнитьЗапрос(СтрокаСоединения, "SELECT A.ARGUMENT_NAME, A.DATA_TYPE, a.SEQUENCE, a.IN_OUT FROM USER_ARGUMENTS A ,ALL_OBJECTS O WHERE A.OBJECT_ID = O.OBJECT_ID AND O.OBJECT_NAME = '"+СписокПараметров[0]+"' AND A.OBJECT_NAME = '"+СписокПараметров[1]+"'",,,Истина);
	КонецЕсли;
	Возврат ТаблицаРезультата;
КонецФункции

Функция ВыполнитьЗапросКБазе(База, ТипЗапроса="OracleQuery", ТекстЗапроса, ТекстКоманды="", СписокПараметров=Неопределено) Экспорт
	СтруктураОтвета = NSI_ОбщиеПроцедуры.ПолучитьПустуюСтруктуруОтвета();
	Если СписокПараметров = Неопределено Тогда
		СписокПараметров = Новый Массив;
	КонецЕсли;
	Если ТипЗнч(База) = Тип("Строка") Тогда
		Попытка
			БазаСсылка = NSI_МодульПовторногоИспользования.ПолучитьСсылкуИБПоИмениБазы(База);
		Исключение
			СтруктураОтвета.IsErrors = Истина;
			СтруктураОтвета.ErrorDescription = ОписаниеОшибки();
			Возврат СтруктураОтвета;
		КонецПопытки;
	ИначеЕсли ТипЗнч(База)=Тип("СправочникСсылка.NSI_СписокВИБ") Тогда
		БазаСсылка = База;
	КонецЕсли;
	Если БазаСсылка.ВидБД = Перечисления.NSI_ВидыБД.Oracle Тогда
		Если Не ТипЗапроса = "OracleQuery" И Не ТипЗапроса = "OracleStoredProc" Тогда
			СтруктураОтвета.IsErrors = Истина;
			СтруктураОтвета.ErrorDescription = "Для баз Oracle тип запроса должен быть Oracle";
			Возврат СтруктураОтвета;
		КонецЕсли;
		СтрокаСоединения = "Provider=OraOLEDB.Oracle;Password="+БазаСсылка.Oracle_password+";User ID="+БазаСсылка.Oracle_user+";Data Source="+БазаСсылка.Oracle_schema+";Persist Security Info=False;";
		Если ТипЗапроса = "OracleQuery" Тогда
			Попытка
				СтрокаОшибок = "";
				ТаблицаРезультата = NSI_РаботаСАДО.ВыполнитьЗапрос(СтрокаСоединения, ТекстЗапроса,ТекстКоманды, СтрокаОшибок, Истина);
				Если ЗначениеЗаполнено(СтрокаОшибок) Тогда
					ВызватьИсключение СтрокаОшибок;
				КонецЕсли;
				СтруктураОтвета.ReturnData = Новый ХранилищеЗначения(ТаблицаРезультата, Новый СжатиеДанных(9));
			Исключение
				СтруктураОтвета.IsErrors = Истина;
				СтруктураОтвета.ErrorDescription = ОписаниеОшибки();
				Возврат СтруктураОтвета;
			КонецПопытки;
		Иначе
			//Пока не сделано
			//Команда = ПолучитьСоединение(СтрокаСоединения, СтрокаОшибок);
			//Команда.CommandText = ТекстЗапроса;
			//Команда.CommandType = 4;
			//Команда.NamedParameters = Истина;
			//
			//Для Каждого Параметр Из СписокПараметров Цикл
			//	Param = Команда.CreateParameter(Параметр.Ключ, 4, 1, ,  Параметр.Значение);
			//	Команда.Parameters.Append(Param);
			//КонецЦикла;
			//Попытка
			//	Команда.Execute();
			//Исключение
			//	Отказ = Истина;
			//	Сообщить(ОписаниеОшибки());
			//КонецПопытки;
			СтруктураОтвета.IsErrors = Истина;
			СтруктураОтвета.ErrorDescription = "Вариант вызова пока не реализован.";
			Возврат СтруктураОтвета;
		КонецЕсли;
	Иначе
		Если ТипЗапроса = "OracleQuery" ИЛИ ТипЗапроса = "OracleStoredProc" Тогда
			СтруктураОтвета.IsErrors = Истина;
			СтруктураОтвета.ErrorDescription = "Для баз 1С тип запроса должен быть не Oracle";
			Возврат СтруктураОтвета;
		КонецЕсли;
		Если ТипЗнч(СписокПараметров) = Тип("ОбъектXDTO") Тогда
			Parameters = СписокПараметров;
		Иначе 
			Parameters = СериализаторXDTO.ЗаписатьXDTO(СписокПараметров);
		КонецЕсли;
		Попытка
			Connector = NSI_МодульПовторногоИспользования.ПолучитьСоединениеПоИмениБазы(БазаСсылка.ИмяБазы);
			Если Connector = Неопределено Тогда
				Возврат "Не удалось подключить базу!" + БазаСсылка.ИмяБазы;
			Иначе
				XDTOОтвет = Connector.RunQueryStorage(ТекстЗапроса, Parameters);
				СтруктураОтвета.ReturnData = XDTOОтвет;
			КонецЕсли;
		Исключение
			СтруктураОтвета.IsErrors = Истина;
			СтруктураОтвета.ErrorDescription = ОписаниеОшибки();
			Возврат СтруктураОтвета;
		КонецПопытки;		
	КонецЕсли;
	Возврат СтруктураОтвета;
КонецФункции

