//{Функция ПолучитьХэш(СоответствиеДанных)
// Функция возвращает хэш SHA1 по любому сериализуемому объекту (соответствие, структура, таблица значений и т.д.)
// Функция используется для хэширования ключей и индексации полей 
//}
Функция ПолучитьХэш(СоответствиеДанных) Экспорт
	Хэш = Новый ХешированиеДанных(ХешФункция.SHA1);
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку("UTF-8");
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, СоответствиеДанных);
	СтрокаСоответствия = ЗаписьXML.Закрыть();
	Хэш.Добавить(СтрокаСоответствия);
	Возврат Base64Строка(Хэш.ХешСумма);
КонецФункции

//{Функция ПолучитьХэшИндексаПоля(Поле, Значение)
// Функция используется для быстрого получения хэша для соответствия (Поле - Значение)
//}
Функция ПолучитьХэшИндексаПоля(Поле, Значение) Экспорт
	СоответствиеИндекса = Новый Соответствие;
	СоответствиеИндекса.Вставить(Поле, Значение);
	Возврат ПолучитьХэш(СоответствиеИндекса);
КонецФункции

//{Процедура ОбновитьХэшКлючевыхПолейПередЗаписью(МастерДанныеОбъект, ОписаниеПолей, СоответствиеПолей) Экспорт
// Параметры:
// 	МастерДанныеОбъект - объект, типа СправочникСсылка.NSI_МастерДанные, ключ которого необходимо зафиксировать.
//	ОписаниеПолей - объект, типа ТаблицаЗначений, аналогичный вызову функции ПолучитьОписаниеПолей с видом мастер-данных
// 		как в МастерДанныеОбъект.Владелец
// 	СоответствиеПолей - объект, типа Соответствие, аналогичный вызову функции ПолучитьТекущиеЗначенияПолей для ссылки на мастер-данные 
//  с видом мастер-данных, как в МастерДанныеОбъект.Владелец
// Процедура разработана для заполнения поля ХэшКлюча в мастер-данных хэшированным соответствием ключевых полей и их значений
//}
Процедура ОбновитьХэшКлючевыхПолей(МастерДанныеСсылка, ОписаниеПолей, СоответствиеПолей) Экспорт
	ЗаписьХэша = РегистрыСведений.NSI_ХэшиКлючейМастерДанных.СоздатьМенеджерЗаписи();
	ЗаписьХэша.МастерДанные = МастерДанныеСсылка;
	ЗаписьХэша.ХэшКлюча = ПолучитьХэшКлюча(ОписаниеПолей, СоответствиеПолей);
	ЗаписьХэша.Записать(Истина);
КонецПроцедуры

Функция ОбновитьХэшиВсехМД(ВидМД, ОписаниеПолейГруппы, ОписаниеПолейЭлемента) Экспорт
	ЗапросМД = Новый Запрос("ВЫБРАТЬ
	                        |	NSI_ХэшиКлючейМастерДанных.МастерДанные,
	                        |	NSI_ХэшиКлючейМастерДанных.ХэшКлюча,
	                        |	1 КАК КоличествоОдинаковыхХэшей,
	                        |	NSI_ХэшиКлючейМастерДанных.ХэшКлюча КАК ХэшКлючаНовый,
	                        |	NSI_ХэшиКлючейМастерДанных.МастерДанные.ЭтоГруппа КАК ЭтоГруппа
	                        |ИЗ
	                        |	РегистрСведений.NSI_ХэшиКлючейМастерДанных КАК NSI_ХэшиКлючейМастерДанных
	                        |ГДЕ
	                        |	NSI_ХэшиКлючейМастерДанных.МастерДанные.Владелец = &ВидМД");
	ЗапросМД.УстановитьПараметр("ВидМД", ВидМД);
	ТЗХэшей = ЗапросМД.Выполнить().Выгрузить();
	Для Каждого СтрокаТЗ Из ТЗХэшей Цикл
		Если СтрокаТЗ.ЭтоГруппа Тогда
			СтрокаТЗ.ХэшКлючаНовый = ПолучитьХэшКлюча(ОписаниеПолейГруппы, ПолучитьТекущиеЗначенияПолей(СтрокаТЗ.МастерДанные));
		Иначе
			СтрокаТЗ.ХэшКлючаНовый = ПолучитьХэшКлюча(ОписаниеПолейЭлемента, ПолучитьТекущиеЗначенияПолей(СтрокаТЗ.МастерДанные));
		КонецЕсли;
	КонецЦикла;
	ТЗХэшейСвернутая = ТЗХэшей.Скопировать();
	ТЗХэшейСвернутая.Свернуть("ХэшКлючаНовый", "КоличествоОдинаковыхХэшей");
	Если ТЗХэшейСвернутая.Количество()<ТЗХэшей.Количество() Тогда
		Сообщить("После обновления хэшей мастер-данных обнаружено дублирование ключевых полей. Обновление вида мастер-данных не может быть выполнено.");
		Возврат Ложь;
	Иначе
		НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
		Попытка
			Для Каждого СтрокаТЗ Из ТЗХэшей Цикл
				ЗаписьХэша = РегистрыСведений.NSI_ХэшиКлючейМастерДанных.СоздатьМенеджерЗаписи();
				ЗаписьХэша.МастерДанные = СтрокаТЗ.МастерДанные;
				ЗаписьХэша.ХэшКлюча = СтрокаТЗ.ХэшКлючаНовый;
				ЗаписьХэша.Записать(Истина);
			КонецЦикла;
			ЗафиксироватьТранзакцию();
			Возврат Истина;
		Исключение
			ОтменитьТранзакцию();
			Сообщить("Не удалось обновить хэши ключей мастер-данных.");
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
КонецФункции


//{Функция ПолучитьХэшКлюча(ОписаниеПолей, СоответствиеПолей) Экспорт
// Параметры:
//	ОписаниеПолей - объект, типа ТаблицаЗначений, аналогичный вызову функции ПолучитьОписаниеПолей с определенным видом мастер-данных
// 	СоответствиеПолей - объект, типа Соответствие, аналогичный вызову функции ПолучитьТекущиеЗначенияПолей для ссылки на мастер-данные 
//  с определенным видом мастер-данных
// Функция возвращает хэшированное соответствием ключевых полей и их значений
//}
Функция ПолучитьХэшКлюча(ОписаниеПолей, СоответствиеПолей) Экспорт
	СоответствиеКлючевыхПолей = Новый Соответствие;
	Для Каждого СтрокаОписанияПолей Из ОписаниеПолей Цикл
		Если СтрокаОписанияПолей.Ключевое Тогда
			СоответствиеКлючевыхПолей.Вставить(СтрокаОписанияПолей.ИмяПоля, СоответствиеПолей[СтрокаОписанияПолей.ИмяПоля]);
		КонецЕсли;
	КонецЦикла;
	Возврат ПолучитьХэш(СоответствиеКлючевыхПолей);
КонецФункции

Функция ПолучитьПредставлениеКлюча(ОписаниеПолей, СоответствиеПолей) Экспорт
	СтрокаПредставленияКлюча = "";
	Для Каждого СтрокаОписанияПолей Из ОписаниеПолей Цикл
		Если СтрокаОписанияПолей.Ключевое Тогда
			СтрокаПредставленияКлюча = СтрокаПредставленияКлюча + ?(ЗначениеЗаполнено(СтрокаПредставленияКлюча),", ","")+СтрокаОписанияПолей.ИмяПоля+" = "+XMLСтрока(СоответствиеПолей[СтрокаОписанияПолей.ИмяПоля]);
		КонецЕсли;
	КонецЦикла;
	Возврат СтрокаПредставленияКлюча;
КонецФункции



//{Процедура ОбновитьЗначенияПолейИИндексыПослеЗаписи(МастерДанныеСсылка, ОписаниеПолей, СоответствиеПолей) Экспорт
// Параметры:
// 	МастерДанныеОбъект - объект, типа СправочникСсылка.NSI_МастерДанные, значения полей и индексов которого необходимо зафиксировать.
//	ОписаниеПолей - объект, типа ТаблицаЗначений, аналогичный вызову функции ПолучитьОписаниеПолей с видом мастер-данных
// 		как в МастерДанныеСсылка.Владелец
// 	СоответствиеПолей - объект, типа Соответствие, аналогичный вызову функции ПолучитьТекущиеЗначенияПолей для ссылки на мастер-данные 
//  с видом мастер-данных, как в МастерДанныеСсылка.Владелец
// Процедура заполняет регистры сведений NSI_НепериодическиеПоляМД, NSI_ПериодическиеПоляМД, NSI_НеПериодическиеИндексыМД, NSI_ПериодическиеИндексыМД
//}
Процедура ОбновитьЗначенияПолейИИндексыПослеЗаписи(МастерДанныеСсылка, ОписаниеПолей, СоответствиеПолей) Экспорт
	ДатаВнесенияИзменений = ТекущаяДата();
	ТекущиеЗначенияПолей = ПолучитьТекущиеЗначенияПолей(МастерДанныеСсылка, ДатаВнесенияИзменений);
	ПериодическиеПоля = РегистрыСведений.NSI_ПериодическиеПоляМД.СоздатьНаборЗаписей();
	ПериодическиеПоля.Отбор.МастерДанные.Установить(МастерДанныеСсылка);
	ПериодическиеПоля.Отбор.Период.Установить(ДатаВнесенияИзменений);
	НеПериодическиеПоля = РегистрыСведений.NSI_НепериодическиеПоляМД.СоздатьНаборЗаписей();
	НеПериодическиеПоля.Отбор.МастерДанные.Установить(МастерДанныеСсылка);
	Для Каждого СтрокаОписанияПоля Из ОписаниеПолей Цикл
		ИмяПоля = СтрокаОписанияПоля.ИмяПоля;
		НовоеЗначениеПоля = СоответствиеПолей[ИмяПоля];
		ТекущееЗначениеПоля = ТекущиеЗначенияПолей[ИмяПоля];
		Если СтрокаОписанияПоля.Периодическое Тогда
			Если НовоеЗначениеПоля=ТекущееЗначениеПоля Тогда
				Продолжить;
			КонецЕсли;
			ЗаписьЗначенияПоля = ПериодическиеПоля.Добавить();
			ЗаписьЗначенияПоля.Период = ДатаВнесенияИзменений;
		Иначе                           
			ЗаписьЗначенияПоля = НеПериодическиеПоля.Добавить();
		КонецЕсли;
		ЗаписьЗначенияПоля.МастерДанные = МастерДанныеСсылка;
		ЗаписьЗначенияПоля.ИмяПоля = ИмяПоля;
		Если ТипЗнч(НовоеЗначениеПоля)=Тип("Строка") Тогда
			ЗаписьЗначенияПоля.ЗначениеСтрока = НовоеЗначениеПоля;
		ИначеЕсли ТипЗнч(НовоеЗначениеПоля)=Тип("Дата") Тогда
			ЗаписьЗначенияПоля.ЗначениеДата = НовоеЗначениеПоля;
		ИначеЕсли ТипЗнч(НовоеЗначениеПоля)=Тип("Булево") Тогда
			ЗаписьЗначенияПоля.ЗначениеБулево = НовоеЗначениеПоля;
		ИначеЕсли ТипЗнч(НовоеЗначениеПоля)=Тип("Число") Тогда
			ЗаписьЗначенияПоля.ЗначениеЧисло = НовоеЗначениеПоля;
		Иначе
			ЗаписьЗначенияПоля.ЗначениеСсылка = НовоеЗначениеПоля;
		КонецЕсли;			
		ЗаписьЗначенияПоля.Хэш = ПолучитьХэшИндексаПоля(СтрокаОписанияПоля.ИмяПоля, НовоеЗначениеПоля);
	КонецЦикла;
	Если ПериодическиеПоля.Количество()>0 Тогда
		ПериодическиеПоля.Записать(Истина);
	КонецЕсли;
	Если НеПериодическиеПоля.Количество()>0 Тогда
		НеПериодическиеПоля.Записать(Истина);
	КонецЕсли;
КонецПроцедуры

//{Функция ПолучитьТекущиеЗначенияПолей(МастерДанныеСсылка, ДатаПолученияДанных=Неопределено, ЭтоГруппа=Ложь)
// Параметры:
// 	МастерДанныеСсылка - объект, типа СправочникСсылка.NSI_МастерДанные, значения полей и индексов которого необходимо получить.
//	ДатаПолученияДанных - дата на которую необходимо получить значения полей, помеченных, как периодические. Если параметр опущен - возвращаются
// 		значения на текущую дату.
// Функция возвращает соответствие где ключом является ссылка на описание поля, а значением - текущее значение данного поля.
// Набор полей учитывает, является ли переданная МастерДанныеСсылка группой или элементом и выдает соответствующий список полей
// при этом, если данные по какому-либо реквизиту в регистре не заполнены - выкидывается приведенное пустое значение поля.
//}
Функция ПолучитьТекущиеЗначенияПолей(МастерДанныеСсылка, ДатаПолученияДанных=Неопределено) Экспорт
	Если ДатаПолученияДанных=Неопределено Тогда
		ДатаПолученияДанных = ТекущаяДата();
	КонецЕсли;
	ТекущиеЗначенияПолей = Новый Структура;
	ОписаниеПолей = NSI_РаботаСМастерДаннымиСерверПовторноеИспользование.ПолучитьОписаниеПолей(МастерДанныеСсылка.Владелец, МастерДанныеСсылка.ЭтоГруппа);
	ЭтоГруппа = МастерДанныеСсылка.ЭтоГруппа;
	ЗапросТекущихЗначенийПолей = Новый Запрос("ВЫБРАТЬ
	                                          |	NSI_ПериодическиеПоляМДСрезПоследних.ИмяПоля,
	                                          |	NSI_ПериодическиеПоляМДСрезПоследних.ЗначениеСтрока,
	                                          |	NSI_ПериодическиеПоляМДСрезПоследних.ЗначениеБулево,
	                                          |	NSI_ПериодическиеПоляМДСрезПоследних.ЗначениеЧисло,
	                                          |	NSI_ПериодическиеПоляМДСрезПоследних.ЗначениеДата,
	                                          |	NSI_ПериодическиеПоляМДСрезПоследних.ЗначениеСсылка
	                                          |ИЗ
	                                          |	РегистрСведений.NSI_ПериодическиеПоляМД.СрезПоследних(&ДатаПолученияДанных, МастерДанные = &МастерДанные) КАК NSI_ПериодическиеПоляМДСрезПоследних
	                                          |
	                                          |ОБЪЕДИНИТЬ ВСЕ
	                                          |
	                                          |ВЫБРАТЬ
	                                          |	NSI_НепериодическиеПоляМД.ИмяПоля,
	                                          |	NSI_НепериодическиеПоляМД.ЗначениеСтрока,
	                                          |	NSI_НепериодическиеПоляМД.ЗначениеБулево,
	                                          |	NSI_НепериодическиеПоляМД.ЗначениеЧисло,
	                                          |	NSI_НепериодическиеПоляМД.ЗначениеДата,
	                                          |	NSI_НепериодическиеПоляМД.ЗначениеСсылка
	                                          |ИЗ
	                                          |	РегистрСведений.NSI_НепериодическиеПоляМД КАК NSI_НепериодическиеПоляМД
	                                          |ГДЕ
	                                          |	NSI_НепериодическиеПоляМД.МастерДанные = &МастерДанные");
	ЗапросТекущихЗначенийПолей.УстановитьПараметр("МастерДанные", МастерДанныеСсылка);
	ЗапросТекущихЗначенийПолей.УстановитьПараметр("ДатаПолученияДанных", ДатаПолученияДанных);
	ВыгрузкаТекущихЗначенийПолей = ЗапросТекущихЗначенийПолей.Выполнить().Выгрузить();	
	Для Каждого СтрокаОписания Из ОписаниеПолей Цикл
		Если ЭтоГруппа Тогда
			Если СтрокаОписания.ИспользованиеПоля = Перечисления.NSI_ИспользованиеПоляМД.ДляЭлемента Тогда
				Продолжить;
			КонецЕсли;
		Иначе
			Если СтрокаОписания.ИспользованиеПоля = Перечисления.NSI_ИспользованиеПоляМД.ДляГруппы Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТипПоля = NSI_РаботаСМастерДаннымиСервер.ПрочитатьОбъектИзXML(СтрокаОписания.ТипПоля);
		ВыгрузкаПоля = ВыгрузкаТекущихЗначенийПолей.Найти(СтрокаОписания.ИмяПоля, "ИмяПоля");
		ЗначениеПоля = ТипПоля.ПривестиЗначение("");
		Если Не ВыгрузкаПоля = Неопределено Тогда
			Для Каждого ВозможныйТипПоля Из ТипПоля.Типы() Цикл
				Если ВозможныйТипПоля = Тип("Строка") Тогда
					ЗначениеПоля = ВыгрузкаПоля.ЗначениеСтрока;
				ИначеЕсли ВозможныйТипПоля = Тип("Дата") Тогда
					ЗначениеПоля = ВыгрузкаПоля.ЗначениеДата;
				ИначеЕсли ВозможныйТипПоля = Тип("Булево") Тогда
					ЗначениеПоля = ВыгрузкаПоля.ЗначениеБулево;
				ИначеЕсли ВозможныйТипПоля = Тип("Число") Тогда
					ЗначениеПоля = ВыгрузкаПоля.ЗначениеЧисло;
				Иначе
					ЗначениеПоля = ВыгрузкаПоля.ЗначениеСсылка;
				КонецЕсли;
				Если ЗначениеЗаполнено(ЗначениеПоля) Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		ТекущиеЗначенияПолей.Вставить(СтрокаОписания.ИмяПоля, ЗначениеПоля);		
	КонецЦикла;
	Возврат ТекущиеЗначенияПолей;
КонецФункции

Функция ЗаблокироватьРегистрСведенийДляИзмененияОбъекта(МастерДанныеСсылка, ИмяРегистра, УникальныйИдентификаторФормыБлокировки) Экспорт
	Попытка
		СписокПолейИзмерений = "";
		СтруктураКлюча = Новый Структура;
		Если Не Метаданные.РегистрыСведений[ИмяРегистра].ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СписокПолейИзмерений = "РегистрБлокировки.Период";
			СтруктураКлюча.Вставить("Период");
		КонецЕсли;
		Для Каждого Измерения Из Метаданные.РегистрыСведений[ИмяРегистра].Измерения Цикл
			СписокПолейИзмерений = СписокПолейИзмерений + ?(ЗначениеЗаполнено(СписокПолейИзмерений), ", ","")+"РегистрБлокировки."+Измерения.Имя;
			СтруктураКлюча.Вставить(Измерения.Имя);
		КонецЦикла;
		ЗапросДляБлокировкиРегистра = Новый Запрос("ВЫБРАТЬ РАЗРЕШЕННЫЕ "+СписокПолейИзмерений+"
		                                           |ИЗ
		                                           |	РегистрСведений."+ИмяРегистра+" КАК РегистрБлокировки
		                                           |ГДЕ
		                                           |	РегистрБлокировки.МастерДанные = &МастерДанные");
		ЗапросДляБлокировкиРегистра.УстановитьПараметр("МастерДанные", МастерДанныеСсылка);
		ВыборкаДляБлокировкиРегистра = ЗапросДляБлокировкиРегистра.Выполнить().Выбрать();
		Пока ВыборкаДляБлокировкиРегистра.Следующий() Цикл
			СтруктураКлюча.Очистить();
			ЗаполнитьЗначенияСвойств(СтруктураКлюча, ВыборкаДляБлокировкиРегистра);
			КлючРегистра = РегистрыСведений[ИмяРегистра].СоздатьКлючЗаписи(СтруктураКлюча);			
			ЗаблокироватьДанныеДляРедактирования(КлючРегистра, , УникальныйИдентификаторФормыБлокировки);
		КонецЦикла;
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции

Функция ЗаблокироватьДанныеПодчиненногоСправочникаДляИзменений(ВладелецСсылка, ИмяСправочника, УникальныйИдентификаторФормыБлокировки) Экспорт
	Попытка
		ЗапросДляБлокировкиСправочника = Новый Запрос("ВЫБРАТЬ СправочникБлокировки.Ссылка
		                                           |ИЗ
		                                           |	Справочник."+ИмяСправочника+" КАК СправочникБлокировки
		                                           |ГДЕ
		                                           |	СправочникБлокировки.Владелец = &ВладелецСсылка");
		ЗапросДляБлокировкиСправочника.УстановитьПараметр("ВладелецСсылка", ВладелецСсылка);
		ВыборкаДляБлокировкиСправочника = ЗапросДляБлокировкиСправочника.Выполнить().Выбрать();
		Пока ВыборкаДляБлокировкиСправочника.Следующий() Цикл
			ЗаблокироватьДанныеДляРедактирования(ВыборкаДляБлокировкиСправочника.Ссылка, , УникальныйИдентификаторФормыБлокировки);
		КонецЦикла;
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции


Функция РазблокироватьРегистрСведенийДляИзмененияОбъекта(МастерДанныеСсылка, ИмяРегистра, УникальныйИдентификаторФормыБлокировки) Экспорт
	Попытка
		СписокПолейИзмерений = "";
		Если Не Метаданные.РегистрыСведений[ИмяРегистра].ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СписокПолейИзмерений = "РегистрБлокировки.Период";
		КонецЕсли;
		Для Каждого Измерения Из Метаданные.РегистрыСведений[ИмяРегистра].Измерения Цикл
			СписокПолейИзмерений = СписокПолейИзмерений + ?(ЗначениеЗаполнено(СписокПолейИзмерений), ", ","")+"РегистрБлокировки."+Измерения.Имя;
		КонецЦикла;
		ЗапросДляБлокировкиРегистра = Новый Запрос("ВЫБРАТЬ "+СписокПолейИзмерений+"
		                                           |ИЗ
		                                           |	РегистрСведений."+ИмяРегистра+" КАК РегистрБлокировки
		                                           |ГДЕ
		                                           |	РегистрБлокировки.МастерДанные = &МастерДанные");
		ЗапросДляБлокировкиРегистра.УстановитьПараметр("МастерДанные", МастерДанныеСсылка);
		ВыборкаДляБлокировкиРегистра = ЗапросДляБлокировкиРегистра.Выполнить().Выбрать();
		Пока ВыборкаДляБлокировкиРегистра.Следующий() Цикл
			КлючРегистра = РегистрыСведений[ИмяРегистра].СоздатьКлючЗаписи();
			ЗаполнитьЗначенияСвойств(КлючРегистра, ВыборкаДляБлокировкиРегистра);
			РазблокироватьДанныеДляРедактирования(КлючРегистра, УникальныйИдентификаторФормыБлокировки);
		КонецЦикла;
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции

Функция РазблокироватьДанныеПодчиненногоСправочникаДляИзменений(ВладелецСсылка, ИмяСправочника, УникальныйИдентификаторФормыБлокировки) Экспорт
	Попытка
		ЗапросДляБлокировкиСправочника = Новый Запрос("ВЫБРАТЬ СправочникБлокировки.Ссылка
		                                           |ИЗ
		                                           |	Справочник."+ИмяСправочника+" КАК СправочникБлокировки
		                                           |ГДЕ
		                                           |	СправочникБлокировки.Владелец = &ВладелецСсылка");
		ЗапросДляБлокировкиСправочника.УстановитьПараметр("ВладелецСсылка", ВладелецСсылка);
		ВыборкаДляБлокировкиСправочника = ЗапросДляБлокировкиСправочника.Выполнить().Выбрать();
		Пока ВыборкаДляБлокировкиСправочника.Следующий() Цикл
			РазблокироватьДанныеДляРедактирования(ВыборкаДляБлокировкиСправочника.Ссылка, УникальныйИдентификаторФормыБлокировки);
		КонецЦикла;
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции

Функция СоздатьТаблицуЗначенийНаФорме(УправляемаяФорма, ТаблицаЗначенийДляСоздания, ИмяТаблицы, ВидимыеНаФормеПоля=Неопределено) Экспорт
	Если ТипЗнч(ВидимыеНаФормеПоля)=Тип("Массив") Тогда
		МассивВидимыхПолей = ВидимыеНаФормеПоля;
	ИначеЕсли ТипЗнч(ВидимыеНаФормеПоля)=Тип("Строка") Тогда
		МассивВидимыхПолей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВидимыеНаФормеПоля, ",", Истина, Истина);
	Иначе
		МассивВидимыхПолей = Новый Массив;
	КонецЕсли;
	// Удаляем таблицу описания полей
	Попытка
		МассивРеквизитовУдаления = Новый Массив;
		МассивРеквизитовУдаления.Добавить(ИмяТаблицы);
		УправляемаяФорма.ИзменитьРеквизиты(,МассивРеквизитовУдаления);
		УправляемаяФорма.Элементы.Удалить(УправляемаяФорма.Элементы[ИмяТаблицы]);
	Исключение
	КонецПопытки;
	// Создаем новую таблицу	
	МассивТипаВыбора = Новый Массив;
    МассивТипаВыбора.Добавить(Тип("ТаблицаЗначений"));
    ОписаниеТипаВыбора = Новый ОписаниеТипов(МассивТипаВыбора);
	МассивРеквизитов = Новый Массив;
    МассивРеквизитов.Добавить(Новый РеквизитФормы(ИмяТаблицы, ОписаниеТипаВыбора, "", "Описание полей мастер-данных"));	
	//передаем колонки из ТЗ в таблицу формы
	Для Каждого Колонка Из ТаблицаЗначенийДляСоздания.Колонки Цикл
		ОписаниеТипаКолонка = Колонка.ТипЗначения;
		ОписаниеТипаКолонкаПроверенный = Новый ОписаниеТипов(ОписаниеТипаКолонка,,"ХранилищеЗначения, NULL");
		НовыйРеквизит = Новый РеквизитФормы(Колонка.Имя, ОписаниеТипаКолонкаПроверенный, ИмяТаблицы, ПреобразоватьИмяЭлементаВТекст(Колонка.Имя));
    	МассивРеквизитов.Добавить(НовыйРеквизит);
	КонецЦикла;
	УправляемаяФорма.ИзменитьРеквизиты(МассивРеквизитов);
	ТаблицаПолейВыбора                          = УправляемаяФорма.Элементы.Добавить(ИмяТаблицы, Тип("ТаблицаФормы"));
    ТаблицаПолейВыбора.ПутьКДанным              = ИмяТаблицы;
    ТаблицаПолейВыбора.Отображение              = ОтображениеТаблицы.Список;
	
	//передаем значения и устанавливаем ширину колонок
	Для Каждого Колонка Из ТаблицаЗначенийДляСоздания.Колонки Цикл		
		Если МассивВидимыхПолей.Количество()>0 Тогда
			Если МассивВидимыхПолей.Найти(Колонка.Имя)=Неопределено Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
        НовыйЭлемент = УправляемаяФорма.Элементы.Добавить(ИмяТаблицы+Колонка.Имя, Тип("ПолеФормы"), ТаблицаПолейВыбора);
        НовыйЭлемент.Вид = ВидПоляФормы.ПолеВвода;
        НовыйЭлемент.ПутьКДанным = ИмяТаблицы+"." + Колонка.Имя;
		НовыйЭлемент.Ширина = 10;		
	КонецЦикла;
КонецФункции

Функция ЗаписатьОбъектВXML(Значение) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение);	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

Функция ПрочитатьОбъектИзXML(СтрокаXML) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);	
КонецФункции

Функция ПреобразоватьИмяЭлементаВТекст(ИмяЭлемента) Экспорт
	ЗаголовокЭлемента = СтрЗаменить(ИмяЭлемента, "Форма", "");
	Пока Найти("1234567890",Прав(ЗаголовокЭлемента,1))>0 Цикл
		ЗаголовокЭлемента = Лев(ЗаголовокЭлемента, СтрДлина(ЗаголовокЭлемента)-1);
	КонецЦикла;
	ЗаголовокЭлемента = СтрЗаменить(ЗаголовокЭлемента, "ОбщаяКоманда", "");   
	ЗаголовокЭлемента = СтрЗаменить(ЗаголовокЭлемента, "КонтекстноеМеню", "");
	ЗаголовокЭлемента = СтрЗаменить(ЗаголовокЭлемента, "КоманднаяПанель", "");
	ТекстЗаголовка = "";
	Для Ц=1 По СтрДлина(ЗаголовокЭлемента) Цикл
		ТекущийСимвол = Сред(ЗаголовокЭлемента, Ц,1);
		Если ТекущийСимвол = "_" Тогда
			Продолжить;                            
		ИначеЕсли Найти("1234567890",ТекущийСимвол)>0 Тогда
			ТекстЗаголовка = ТекстЗаголовка + ?(ЗначениеЗаполнено(ТекстЗаголовка),ТекущийСимвол, "");
		ИначеЕсли ТекущийСимвол = ВРег(ТекущийСимвол) Тогда
			ТекстЗаголовка = ТекстЗаголовка + ?(ЗначениеЗаполнено(ТекстЗаголовка)," "+НРег(ТекущийСимвол), ТекущийСимвол);
		Иначе
			ТекстЗаголовка = ТекстЗаголовка + ТекущийСимвол;
		КонецЕсли;
	КонецЦикла;
	Возврат ТекстЗаголовка;
КонецФункции

Процедура ПолучитьСписокДоступныхПолейМастерДанных(Знач ОписаниеПолей, СписокПолей, ЭтоГруппа) Экспорт
	СписокПолей.Очистить();
	Для Каждого СтрокаПоля Из ОписаниеПолей Цикл
		Если ЭтоГруппа И СтрокаПоля.ИспользованиеПоля = Перечисления.NSI_ИспользованиеПоляМД.ДляЭлемента Тогда
			Продолжить;
		ИначеЕсли Не ЭтоГруппа И СтрокаПоля.ИспользованиеПоля = Перечисления.NSI_ИспользованиеПоляМД.ДляГруппы Тогда
			Продолжить;
		КонецЕсли;                    
		СписокПолей.Добавить(СтрокаПоля.ИмяПоля, СтрокаПоля.СинонимПоля);
	КонецЦикла;
КонецПроцедуры

Функция ПроверитьМакетВидаМастерДанных(ТабличныйДокументМакета, СписокПолей) Экспорт
	МаксимумСтрок = ТабличныйДокументМакета.ВысотаТаблицы;
	МаксимумКолонок = ТабличныйДокументМакета.ШиринаТаблицы;
	Для НомерСтроки = 1 По МаксимумСтрок Цикл
		Для НомерКолонки = 1 По МаксимумКолонок Цикл
			ТекущаяОбластьПроверки = ТабличныйДокументМакета.Область(НомерСтроки, НомерКолонки);
			Если ЗначениеЗаполнено(ТекущаяОбластьПроверки.Текст) Тогда
				Если СписокПолей.НайтиПоЗначению(ТекущаяОбластьПроверки.Текст) = Неопределено Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЕсли;	
		КонецЦикла;
	КонецЦикла;
	Возврат Истина;
КонецФункции

Функция ПолучитьСписокВидовДанных() Экспорт
	ЗапросВидов = Новый Запрос("ВЫБРАТЬ РАЗРЕШЕННЫЕ
	                           |	NSI_ВидыМД.Ссылка
	                           |ИЗ
	                           |	Справочник.NSI_ВидыМД КАК NSI_ВидыМД");
	Список = Новый СписокЗначений;
	Список.ЗагрузитьЗначения(ЗапросВидов.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка"));
	Возврат Список;
КонецФункции


Функция СоздатьГруппуЭлементовФормы(УправляемаяФорма, ИмяГруппы, Родитель, ВидГруппировки, ШиринаПодчиненныхЭлементов=Неопределено)
	НоваяГруппа = УправляемаяФорма.Элементы.Добавить(ИмяГруппы, Тип("ГруппаФормы"), Родитель);
	НоваяГруппа.Вид = ВидГруппыФормы.ОбычнаяГруппа;
	НоваяГруппа.ОтображатьЗаголовок = Ложь;
    НоваяГруппа.Группировка = ВидГруппировки;
	НоваяГруппа.Отображение = ОтображениеОбычнойГруппы.Нет;
	Если Не ШиринаПодчиненныхЭлементов=Неопределено Тогда
		НоваяГруппа.ШиринаПодчиненныхЭлементов = ШиринаПодчиненныхЭлементов;
	КонецЕсли;
	Возврат НоваяГруппа;
КонецФункции

Функция СоздатьКомандуПериодическогоРеквизитаФормы(УправляемаяФорма, ИмяРеквизита)
	НоваяКоманда = УправляемаяФорма.Команды.Добавить("ДР_"+ИмяРеквизита+"_Периодический");
	НоваяКоманда.Действие = "ПоказатьЗначенияПериодическогоРеквизита";
	НоваяКоманда.Картинка = БиблиотекаКартинок.NSI_ПериодическийРеквизит;
	НоваяКоманда.Отображение = ОтображениеКнопки.Картинка;
	Возврат НоваяКоманда;
КонецФункции

Функция ПолучитьРеквизитФормы(УправляемаяФорма, ИмяРеквизита, Периодический, ТипРеквизита=Неопределено, ЗаголовокРеквизита=Неопределено)
	Если ТипРеквизита = Неопределено Тогда
		ТипРеквизита = Новый ОписаниеТипов("Строка");
	КонецЕсли;
	Если ЗаголовокРеквизита = Неопределено Тогда
		ЗаголовокРеквизита = ПреобразоватьИмяЭлементаВТекст(ИмяРеквизита);
	КонецЕсли;
	ОписаниеТипаПроверенный = Новый ОписаниеТипов(ТипРеквизита,,"ХранилищеЗначения, NULL");
	СтруктураРеквизита = Новый Структура;
	СтруктураРеквизита.Вставить("Реквизит", Новый РеквизитФормы(ИмяРеквизита, ОписаниеТипаПроверенный, , ЗаголовокРеквизита));
	Если Периодический Тогда
		СтруктураРеквизита.Вставить("КомандаПериодичности", СоздатьКомандуПериодическогоРеквизитаФормы(УправляемаяФорма, ИмяРеквизита));
	КонецЕсли;
	Возврат СтруктураРеквизита;	
КонецФункции

Функция ЗаполнитьГруппуФормыПоМакетуВидаМастерДанных(УправляемаяФорма, ВидМастерДанных, ЭтоГруппа, ЭлементРодитель=Неопределено) Экспорт
	СписокПолей = Новый СписокЗначений;
	ОписаниеПолей = NSI_РаботаСМастерДаннымиСерверПовторноеИспользование.ПолучитьОписаниеПолей(ВидМастерДанных, ЭтоГруппа);
	ПолучитьСписокДоступныхПолейМастерДанных(ОписаниеПолей, СписокПолей, ЭтоГруппа);
	МакетМастерДанных = NSI_РаботаСМастерДаннымиСерверПовторноеИспользование.ПолучитьМакетМастерДанных(ВидМастерДанных, ЭтоГруппа);
	Если Не ПроверитьМакетВидаМастерДанных(МакетМастерДанных, СписокПолей) Тогда
		ВызватьИсключение "Неправильно настроен макет данных мастер-данных";
	КонецЕсли;
	МассивДобавляемыхРеквизитов = Новый Массив;
	Для Каждого ОписаниеПоля Из ОписаниеПолей Цикл
		Если ЭтоГруппа И ОписаниеПоля.ИспользованиеПоля = Перечисления.NSI_ИспользованиеПоляМД.ДляЭлемента Тогда
			Продолжить;
		ИначеЕсли Не ЭтоГруппа И ОписаниеПоля.ИспользованиеПоля = Перечисления.NSI_ИспользованиеПоляМД.ДляГруппы Тогда
			Продолжить;
		КонецЕсли;
		СтруктураРеквизита = ПолучитьРеквизитФормы(УправляемаяФорма, ОписаниеПоля.ИмяПоля, ОписаниеПоля.Периодическое, ПрочитатьОбъектИзXML(ОписаниеПоля.ТипПоля), ОписаниеПоля.СинонимПоля);
		МассивДобавляемыхРеквизитов.Добавить(СтруктураРеквизита.Реквизит);
	КонецЦикла;
	УправляемаяФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);
	Если ЭлементРодитель = Неопределено Тогда
		ЭлементРодитель = УправляемаяФорма;
	КонецЕсли;
	СоздатьЭлементыФормыПоМакету(УправляемаяФорма, ЭлементРодитель, МакетМастерДанных, ОписаниеПолей);
КонецФункции

Функция СоздатьЭлементыФормыПоМакету(УправляемаяФорма, ЭлементРодитель, Макет, ОписаниеПолей)
	МаксимумСтрок = Макет.ВысотаТаблицы;
	МаксимумКолонок = Макет.ШиринаТаблицы;
	Для НомерСтроки = 1 По МаксимумСтрок Цикл
		ГруппаСтроки = СоздатьГруппуЭлементовФормы(УправляемаяФорма, "ГруппаДР_"+Формат(НомерСтроки,"ЧЦ=2; ЧВН="), ЭлементРодитель, ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная, ШиринаПодчиненныхЭлементовФормы.Одинаковая);
		Для НомерКолонки = 1 По МаксимумКолонок Цикл
			ГруппаЯчейки = СоздатьГруппуЭлементовФормы(УправляемаяФорма, "ГруппаДР_"+Формат(НомерСтроки,"ЧЦ=2; ЧВН=")+"_"+Формат(НомерКолонки,"ЧЦ=2; ЧВН="), ГруппаСтроки, ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная);
			ТекущаяОбластьПроверки = Макет.Область(НомерСтроки, НомерКолонки);
			Если ЗначениеЗаполнено(ТекущаяОбластьПроверки.Текст) Тогда
				СтрокаОписания = ОписаниеПолей.Найти(ТекущаяОбластьПроверки.Текст, "ИмяПоля");
				Если Не СтрокаОписания = Неопределено Тогда
					ТипПоляЭлемента = ПрочитатьОбъектИзXML(СтрокаОписания.ТипПоля);
					Если ТипЗнч(ТипПоляЭлемента) = Тип("ОписаниеТипов") Тогда
						НовыйЭлемент = УправляемаяФорма.Элементы.Добавить("ЭлементДР_"+СтрокаОписания.ИмяПоля, Тип("ПолеФормы"), ГруппаЯчейки);							
						Если ТипПоляЭлемента.Типы().Количество()>1 Тогда	
							НовыйЭлемент.Вид = ВидПоляФормы.ПолеВвода;
							НовыйЭлемент.РастягиватьПоГоризонтали = Истина;
						ИначеЕсли ТипПоляЭлемента.СодержитТип(Тип("Булево")) Тогда
							НовыйЭлемент.Вид = ВидПоляФормы.ПолеФлажка;
						Иначе
							НовыйЭлемент.Вид = ВидПоляФормы.ПолеВвода;
							НовыйЭлемент.РастягиватьПоГоризонтали = Истина;
						КонецЕсли;
						НовыйЭлемент.ПутьКДанным = СтрокаОписания.ИмяПоля;
						Если СтрокаОписания.Ключевое Тогда
							НовыйЭлемент = УправляемаяФорма.Элементы.Добавить("КлючДР_"+СтрокаОписания.ИмяПоля, Тип("ДекорацияФормы"), ГруппаЯчейки);
							НовыйЭлемент.Вид = ВидДекорацииФормы.Картинка;
							НовыйЭлемент.Картинка = БиблиотекаКартинок.NSI_КлючевойРеквизит;
							НовыйЭлемент.Масштабировать = Ложь;
							НовыйЭлемент.Ширина = 1;
							НовыйЭлемент.Высота = 1;
							НовыйЭлемент.РастягиватьПоВертикали = Ложь;
							НовыйЭлемент.РастягиватьПоГоризонтали = Ложь;
						КонецЕсли;
						Если СтрокаОписания.Периодическое Тогда
							НоваяКнопка = УправляемаяФорма.Элементы.Добавить("КнопкаДР_"+СтрокаОписания.ИмяПоля, Тип("КнопкаФормы"), ГруппаЯчейки);
							НоваяКнопка.ИмяКоманды = "ДР_"+СтрокаОписания.ИмяПоля+"_Периодический";
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;	
		КонецЦикла;
	КонецЦикла;
	Возврат Истина;	
КонецФункции

Функция ПолучитьТипРеквизита(ВидМастерДанных, ИмяПоля)
	ОписаниеПолейМД = NSI_РаботаСМастерДаннымиСерверПовторноеИспользование.ПолучитьОписаниеПолей(ВидМастерДанных);
	СтрокаОписанияПоля = ОписаниеПолейМД.Найти(ИмяПоля, "ИмяПоля");
	Если Не СтрокаОписанияПоля = Неопределено Тогда
		Если ЗначениеЗаполнено(СтрокаОписанияПоля.ТипПоля) Тогда
			Возврат ПрочитатьОбъектИзXML(СтрокаОписанияПоля.ТипПоля);
		Иначе
			Возврат Новый ОписаниеТипов;
		КонецЕсли;
	КонецЕсли;
КонецФункции


Функция ПолучитьИсториюПериодическогоРеквизита(МастерДанныеСсылка, ИмяПоля) Экспорт
	Если Не ЗначениеЗаполнено(МастерДанныеСсылка) Тогда
		ТаблицаИстории = Новый ТаблицаЗначений;
		ТаблицаИстории.Колонки.Добавить("Период", Новый ОписаниеТипов("Дата",,,,,Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя)));
		ТаблицаИстории.Колонки.Добавить("Значение");
		Возврат ТаблицаИстории;
	КонецЕсли;
	ТипПериодическогоРеквизита = ПолучитьТипРеквизита(МастерДанныеСсылка.Владелец, ИмяПоля);
	ЗапросИсторииПериодическогоРеквизита = Новый Запрос("ВЫБРАТЬ
	                                                    |	NSI_ПериодическиеПоляМД.Период КАК Период,
	                                                    |	NSI_ПериодическиеПоляМД.ЗначениеБулево,
	                                                    |	NSI_ПериодическиеПоляМД.ЗначениеЧисло,
	                                                    |	NSI_ПериодическиеПоляМД.ЗначениеСтрока,
	                                                    |	NSI_ПериодическиеПоляМД.ЗначениеДата,
	                                                    |	NSI_ПериодическиеПоляМД.ЗначениеСсылка
	                                                    |ИЗ
	                                                    |	РегистрСведений.NSI_ПериодическиеПоляМД КАК NSI_ПериодическиеПоляМД
	                                                    |ГДЕ
	                                                    |	NSI_ПериодическиеПоляМД.МастерДанные = &МастерДанные
	                                                    |	И NSI_ПериодическиеПоляМД.ИмяПоля = &ИмяПоля
	                                                    |
	                                                    |УПОРЯДОЧИТЬ ПО
	                                                    |	Период");
	ЗапросИсторииПериодическогоРеквизита.УстановитьПараметр("МастерДанные", МастерДанныеСсылка);
	ЗапросИсторииПериодическогоРеквизита.УстановитьПараметр("ИмяПоля", ИмяПоля);
	ВыборкаИсторииПериодическогоРеквизита = ЗапросИсторииПериодическогоРеквизита.Выполнить().Выбрать();
	ТаблицаИстории = Новый ТаблицаЗначений;
	ТаблицаИстории.Колонки.Добавить("Период", Новый ОписаниеТипов("Дата",,,,,Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя)));
	ТаблицаИстории.Колонки.Добавить("Значение", ТипПериодическогоРеквизита);
	Если ТипПериодическогоРеквизита.Типы().Количество()=0 Тогда
		Возврат ТаблицаИстории;
	Иначе
		Пока ВыборкаИсторииПериодическогоРеквизита.Следующий() Цикл
			НоваяСтрокаИстории = ТаблицаИстории.Добавить();
			НоваяСтрокаИстории.Период = ВыборкаИсторииПериодическогоРеквизита.Период;
			Если ТипПериодическогоРеквизита.СодержитТип(Тип("Булево")) Тогда
				Если ЗначениеЗаполнено(ВыборкаИсторииПериодическогоРеквизита.ЗначениеБулево) Тогда
					НоваяСтрокаИстории.Значение = ВыборкаИсторииПериодическогоРеквизита.ЗначениеБулево;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если ТипПериодическогоРеквизита.СодержитТип(Тип("Число")) Тогда
				Если ЗначениеЗаполнено(ВыборкаИсторииПериодическогоРеквизита.ЗначениеЧисло) Тогда
					НоваяСтрокаИстории.Значение = ВыборкаИсторииПериодическогоРеквизита.ЗначениеЧисло;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если ТипПериодическогоРеквизита.СодержитТип(Тип("Строка")) Тогда
				Если ЗначениеЗаполнено(ВыборкаИсторииПериодическогоРеквизита.ЗначениеСтрока) Тогда
					НоваяСтрокаИстории.Значение = ВыборкаИсторииПериодическогоРеквизита.ЗначениеСтрока;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если ТипПериодическогоРеквизита.СодержитТип(Тип("Дата")) Тогда
				Если ЗначениеЗаполнено(ВыборкаИсторииПериодическогоРеквизита.ЗначениеДата) Тогда
					НоваяСтрокаИстории.Значение = ВыборкаИсторииПериодическогоРеквизита.ЗначениеДата;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если ТипПериодическогоРеквизита.СодержитТип(Тип("СправочникСсылка.NSI_СписокВИБ")) ИЛИ ТипПериодическогоРеквизита.СодержитТип(Тип("СправочникСсылка.NSI_МастерДанные")) Тогда
				Если ЗначениеЗаполнено(ВыборкаИсторииПериодическогоРеквизита.ЗначениеСсылка) Тогда
					НоваяСтрокаИстории.Значение = ВыборкаИсторииПериодическогоРеквизита.ЗначениеСсылка;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат ТаблицаИстории;
КонецФункции

Функция УдалитьМастерДанныеПоСсылке(СсылкаМД) Экспорт
	НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
	Попытка
		НаборПолей = РегистрыСведений.NSI_ПериодическиеПоляМД.СоздатьНаборЗаписей();
		НаборПолей.Отбор.МастерДанные.Установить(СсылкаМД);
		НаборПолей.Записать(Истина);
		НаборПолей = РегистрыСведений.NSI_НепериодическиеПоляМД.СоздатьНаборЗаписей();
		НаборПолей.Отбор.МастерДанные.Установить(СсылкаМД);
		НаборПолей.Записать(Истина);
		НаборПолей = РегистрыСведений.NSI_ХэшиКлючейМастерДанных.СоздатьНаборЗаписей();
		НаборПолей.Отбор.МастерДанные.Установить(СсылкаМД);
		НаборПолей.Записать(Истина);
		СсылкаМД.ПолучитьОбъект().Удалить();
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
	КонецПопытки;	
КонецФункции






